<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Brewlio — Find your coffee style</title>

  <meta name="description" content="Brewlio matches you to a coffee style that fits how you actually drink it — setup, milk, and taste included. No jargon. No account. About a minute." />
  <link rel="stylesheet" href="style.css" />

  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>☕</text></svg>">

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <!-- ✅ PATCH (dark mode bullets): ensures .note-list markers are visible even if global resets exist -->
  <style>
    .note-list{
      list-style: disc;
      list-style-position: outside;
      padding-left: 1.25rem;
      margin: 0.75rem 0 0;
    }
    .note-list li{ margin: 0.35rem 0; }
    .note-list li::marker{ color: var(--text, currentColor); }
  </style>
</head>
<body>

  <header class="t-bar">
    <nav class="nav-left" aria-label="Quiz navigation">
      <a class="nav-back" href="index.html">← Back home</a>
    </nav>
    <a href="index.html" class="logo logo-link" aria-label="Brewlio home">
      <span class="logo-main">BREWLIO</span>
      <span class="logo-sub">coffee that just makes sense</span>
    </a>
  </header>

  <div id="greeting" class="greeting" aria-live="polite">
    <strong>Let’s find what actually fits.</strong>
    <span class="tip">About a minute. Pick what sounds like you. No jargon. No account.</span>
  </div>

  <section class="quiz-section">
    <div class="quiz-container">

      <div class="quiz-header">
        <h1>Find your coffee style</h1>
        <p class="quiz-lede">
          There’s no “best” coffee — only coffee that fits your setup and taste.
          <span class="quiz-lede-sub">Free. No account. Retake anytime.</span>
        </p>

        <div class="quiz-meta" aria-label="Progress">
          <span id="stepText" class="step-text">Question 1 of 8</span>
          <span id="stepHint" class="step-hint">Pick one to continue</span>
        </div>
      </div>

      <form id="coffeeQuiz" novalidate>

        <!-- Q1: Brew method -->
<fieldset class="question active" data-q="brew">
  <legend>How do you mostly brew your coffee?</legend>
  <div class="question-gif">
    <video
      class="q-video"
      autoplay
      loop
      muted
      playsinline
      webkit-playsinline
      poster="Assets/roast_fallback.jpg"
      preload="metadata">
      <source src="Assets/Question1.mp4" type="video/mp4">
      <img src="Assets/roast_fallback.jpg" alt="Coffee beans pouring">
    </video>
  </div>

  <div class="options" role="radiogroup" aria-label="Brew method">
    <div class="option">
      <input type="radio" id="brew-espresso" name="brew" value="espresso" required>
      <label for="brew-espresso">Espresso machine <span class="muted">— Breville, Gaggia, similar</span></label>
    </div>
    <div class="option">
      <input type="radio" id="brew-manual" name="brew" value="manual">
      <label for="brew-manual">Manual filter <span class="muted">— V60, AeroPress, pour-over</span></label>
    </div>
    <div class="option">
      <input type="radio" id="brew-batch" name="brew" value="batch">
      <label for="brew-batch">Batch filter <span class="muted">— Moccamaster-style brewers</span></label>
    </div>
    <div class="option">
      <input type="radio" id="brew-body" name="brew" value="body">
      <label for="brew-body">Immersion / stovetop <span class="muted">— French press, moka pot</span></label>
    </div>
    <div class="option">
      <input type="radio" id="brew-other" name="brew" value="other">
      <label for="brew-other">Other or instant <span class="muted">— no judgement here</span></label>
    </div>
  </div>

  <p class="micro-note micro-note--spaced">Pick the one you do most often.</p>
</fieldset>

<!-- Q2: Grinder -->
<fieldset class="question" data-q="grinder">
  <legend>What are you grinding with?</legend>
  <div class="question-gif">
    <video
      class="q-video"
      autoplay
      loop
      muted
      playsinline
      webkit-playsinline
      poster="Assets/roast_fallback.jpg"
      preload="metadata">
      <source src="Assets/Question2.mp4" type="video/mp4">
      <img src="Assets/roast_fallback.jpg" alt="Coffee beans pouring">
    </video>
  </div>

  <div class="options" role="radiogroup" aria-label="Grinder tier">
    <div class="option">
      <input type="radio" id="gr-pre" name="grinder" value="pre-ground" required>
      <label for="gr-pre">Pre-ground coffee <span class="muted">— or I don’t grind at all</span></label>
    </div>
    <div class="option">
      <input type="radio" id="gr-blade" name="grinder" value="blade">
      <label for="gr-blade">Blade grinder <span class="muted">— inconsistent, but common</span></label>
    </div>
    <div class="option">
      <input type="radio" id="gr-entry" name="grinder" value="burr-entry">
      <label for="gr-entry">Entry-level burr <span class="muted">— Smart Grinder Pro, Encore</span></label>
    </div>
    <div class="option">
      <input type="radio" id="gr-good" name="grinder" value="burr-good">
      <label for="gr-good">Good burr grinder <span class="muted">— DF64, Niche, similar</span></label>
    </div>
    <div class="option">
      <input type="radio" id="gr-pro" name="grinder" value="pro">
      <label for="gr-pro">High-end or commercial <span class="muted">— 078s, EK43</span></label>
    </div>
  </div>

  <p class="micro-note micro-note--spaced" id="grinderHint">
    Hand grinders count — placement depends on brew style.
  </p>
</fieldset>

        <!-- Q3: Espresso machine (conditional) -->
        <fieldset class="question" data-q="machine" data-conditional="espresso">
          <legend>If you make espresso, which machine tier is closest?</legend>
          <div class="question-gif">
            <video
              class="q-video"
              autoplay
              loop
              muted
              playsinline
              webkit-playsinline
              poster="Assets/roast_fallback.jpg"
              preload="metadata">
              <source src="Assets/Question3.mp4" type="video/mp4">
              <img src="Assets/roast_fallback.jpg" alt="Coffee beans pouring">
            </video>
          </div>

          <div class="options" role="radiogroup" aria-label="Espresso machine tier">
            <div class="option">
              <input type="radio" id="mach-entry" name="machine" value="entry">
              <label for="mach-entry">Entry-level <span class="muted">— Bambino, basic single boiler</span></label>
            </div>

            <div class="option">
              <input type="radio" id="mach-capable" name="machine" value="capable">
              <label for="mach-capable">Capable <span class="muted">— Gaggia, Silvia</span></label>
            </div>

            <div class="option">
              <input type="radio" id="mach-advanced" name="machine" value="advanced">
              <label for="mach-advanced">Advanced <span class="muted">— dual boiler or HX</span></label>
            </div>

            <div class="option">
              <input type="radio" id="mach-elite" name="machine" value="elite">
              <label for="mach-elite">Prosumer / high-end <span class="muted">— Linea Mini, E61</span></label>
            </div>

            <div class="option">
              <input type="radio" id="mach-notsure" name="machine" value="not-sure">
              <label for="mach-notsure">Not sure <span class="muted">— totally fine</span></label>
            </div>
          </div>
        </fieldset>

        <!-- Q4: Milk -->
        <fieldset class="question" data-q="milk">
          <legend>How do you take your coffee?</legend>
          <div class="question-gif">
            <picture>
              <source srcset="https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExejF3a2ticTA2N2ZvOTBrd2ZqZTNxd2NrbnFheHE0M3NkeTVwbmk0YyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/h55EUEsTG9224/giphy.gif" type="image/gif">
              <img src="Assets/milk_fallback.jpg" alt="Pouring milk into coffee" loading="lazy" />
            </picture>
          </div>

          <div class="options" role="radiogroup" aria-label="Milk preference">
            <div class="option">
              <input type="radio" id="milk-black" name="milk" value="black" required>
              <label for="milk-black">Always black <span class="muted">— no milk</span></label>
            </div>

            <div class="option">
              <input type="radio" id="milk-sometimes" name="milk" value="sometimes">
              <label for="milk-sometimes">Sometimes with milk <span class="muted">— depends on the mood</span></label>
            </div>

            <div class="option">
              <input type="radio" id="milk-always" name="milk" value="always">
              <label for="milk-always">Always with milk <span class="muted">— flat white energy</span></label>
            </div>
          </div>
        </fieldset>

        <!-- Q5: Flavour -->
        <fieldset class="question" data-q="flavour">
          <legend>What flavours do you enjoy most?</legend>
          <div class="question-gif">
           <video
             class="q-video"
             autoplay
             loop
             muted
             playsinline
             webkit-playsinline
             poster="Assets/roast_fallback.jpg"
             preload="metadata">
             <source src="Assets/Question5.mp4" type="video/mp4">
             <img src="Assets/roast_fallback.jpg" alt="Coffee beans pouring">
           </video>
          </div>

          <div class="options" role="radiogroup" aria-label="Flavour preference">
            <div class="option">
              <input type="radio" id="flavour-fruity" name="flavour" value="fruity" required>
              <label for="flavour-fruity">Juicy fruit <span class="muted">— berries, citrus, bright cups</span></label>
            </div>

            <div class="option">
              <input type="radio" id="flavour-clean" name="flavour" value="clean">
              <label for="flavour-clean">Clean & tea-like <span class="muted">— light, delicate, crisp</span></label>
            </div>

            <div class="option">
              <input type="radio" id="flavour-choc" name="flavour" value="chocolate">
              <label for="flavour-choc">Chocolatey & nutty <span class="muted">— caramel, cocoa, comfort</span></label>
            </div>

            <div class="option">
              <input type="radio" id="flavour-balanced" name="flavour" value="balanced">
              <label for="flavour-balanced">Balanced <span class="muted">— nothing too loud</span></label>
            </div>

            <div class="option">
              <input type="radio" id="flavour-bold" name="flavour" value="bold">
              <label for="flavour-bold">Rich & heavy <span class="muted">— big body, low acidity</span></label>
            </div>
          </div>
        </fieldset>

        <!-- Q6: Roast -->
        <fieldset class="question" data-q="roast">
         <div class="question-gif">
           <video
             class="q-video"
             autoplay
             loop
             muted
             playsinline
             webkit-playsinline
             poster="Assets/roast_fallback.jpg"
             preload="metadata">
             <source src="Assets/Question6.mp4" type="video/mp4">
             <img src="Assets/roast_fallback.jpg" alt="Coffee beans pouring">
           </video>
          </div>

          <div class="options" role="radiogroup" aria-label="Roast preference">
            <div class="option">
              <input type="radio" id="roast-light" name="roast" value="light" required>
              <label for="roast-light">Light roast <span class="muted">— more origin character</span></label>
            </div>

            <div class="option">
              <input type="radio" id="roast-medium" name="roast" value="medium">
              <label for="roast-medium">Medium roast <span class="muted">— sweet and balanced</span></label>
            </div>

            <div class="option">
              <input type="radio" id="roast-mediumdark" name="roast" value="medium-dark">
              <label for="roast-mediumdark">Medium-dark roast <span class="muted">— syrupy, comforting</span></label>
            </div>

            <div class="option">
              <input type="radio" id="roast-dark" name="roast" value="dark">
              <label for="roast-dark">Dark roast <span class="muted">— bold, roasty flavours</span></label>
            </div>

            <div class="option">
              <input type="radio" id="roast-any" name="roast" value="any">
              <label for="roast-any">Not sure <span class="muted">— happy to be guided</span></label>
            </div>
          </div>
        </fieldset>

        <!-- Q7: Skill -->
        <fieldset class="question" data-q="skill">
          <legend>How deep are you into coffee?</legend>
          <div class="question-gif">
           <video
             class="q-video"
             autoplay
             loop
             muted
             playsinline
             webkit-playsinline
             poster="Assets/roast_fallback.jpg"
             preload="metadata">
             <source src="Assets/Question7.mp4" type="video/mp4">
             <img src="Assets/roast_fallback.jpg" alt="Coffee beans pouring">
           </video>
          </div>

          <div class="options" role="radiogroup" aria-label="Skill level">
            <div class="option">
              <input type="radio" id="sk-beginner" name="skill" value="beginner" required>
              <label for="sk-beginner">Beginner <span class="muted">— I just want it to taste good</span></label>
            </div>

            <div class="option">
              <input type="radio" id="sk-basic" name="skill" value="basic">
              <label for="sk-basic">Comfortable <span class="muted">— I follow recipes</span></label>
            </div>

            <div class="option">
              <input type="radio" id="sk-inter" name="skill" value="intermediate">
              <label for="sk-inter">Intermediate <span class="muted">— I tweak and adjust</span></label>
            </div>

            <div class="option">
              <input type="radio" id="sk-advanced" name="skill" value="advanced">
              <label for="sk-advanced">Advanced <span class="muted">— ratios and grind size matter</span></label>
            </div>

            <div class="option">
              <input type="radio" id="sk-nerd" name="skill" value="nerd">
              <label for="sk-nerd">Very deep <span class="muted">— this is a real hobby</span></label>
            </div>
          </div>
        </fieldset>

        <!-- Q8: Pain -->
        <fieldset class="question" data-q="pain">
          <legend>What ruins a coffee for you?</legend>
          <div class="question-gif">
              <video
                class="q-video"
                autoplay
                loop
                muted
                playsinline
                webkit-playsinline
                poster="Assets/roast_fallback.jpg"
                preload="metadata">
                <source src="Assets/Question8.mp4" type="video/mp4">
                <img src="Assets/roast_fallback.jpg" alt="Coffee beans pouring">
              </video>
          </div>

          <div class="options" role="radiogroup" aria-label="Biggest coffee frustration">
            <div class="option">
              <input type="radio" id="pn-sour" name="pain" value="sour" required>
              <label for="pn-sour">Sour or sharp <span class="muted">— too acidic</span></label>
            </div>

            <div class="option">
              <input type="radio" id="pn-bitter" name="pain" value="bitter">
              <label for="pn-bitter">Bitter or harsh <span class="muted">— overdone</span></label>
            </div>

            <div class="option">
              <input type="radio" id="pn-weak" name="pain" value="weak">
              <label for="pn-weak">Weak or watery <span class="muted">— no body</span></label>
            </div>

            <div class="option">
              <input type="radio" id="pn-muddy" name="pain" value="muddy">
              <label for="pn-muddy">Muddy or gritty <span class="muted">— unpleasant texture</span></label>
            </div>

            <div class="option">
              <input type="radio" id="pn-inconsistent" name="pain" value="inconsistent">
              <label for="pn-inconsistent">Inconsistent <span class="muted">— never tastes the same</span></label>
            </div>
          </div>
        </fieldset>

        <div class="quiz-controls">
          <button type="button" id="prevBtn" class="quiz-btn secondary" disabled>Previous</button>
          <button type="button" id="nextBtn" class="quiz-btn primary">Next</button>
          <button type="submit" id="submitBtn" class="quiz-btn primary hidden" disabled>Show my style →</button>
        </div>

        <div class="progress-bar" aria-hidden="true">
          <div class="progress"></div>
        </div>

        <p id="errorText" class="quiz-error" role="status" aria-live="polite"></p>
      </form>

      <div id="results" class="results" hidden>
        <h2>Your coffee style match</h2>
        <p class="results-lede">Built for how you brew, what you enjoy, and what your setup can handle.</p>
        <div id="recommendation"></div>

        <div class="results-actions">
          <a href="index.html" class="btn-primary">Back to home</a>
          <button type="button" id="retakeBtn" class="btn-secondary">Retake quiz</button>
        </div>
      </div>

    </div>
  </section>

  <script>
    // Greeting
    (() => {
      const el = document.getElementById('greeting');
      el.innerHTML = `<strong>Let’s find what actually fits.</strong><span class="tip">About a minute. Pick what sounds like you. No jargon. No account.</span>`;
    })();

    // Supabase
    const SUPABASE_URL = "https://opledkjivawysybvbqxe.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable_FxH-YkKnC8mZD8R0hSgXEg_mgrR20K_";

    let sb = null;
    try {
      const ok =
        typeof SUPABASE_URL === "string" && SUPABASE_URL.startsWith("http") && SUPABASE_URL.includes("supabase.co") &&
        typeof SUPABASE_ANON_KEY === "string" && SUPABASE_ANON_KEY.length > 10;
      if (ok && window.supabase?.createClient) sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    } catch (err) {
      console.warn("Supabase init failed:", err);
    }

    const sessionId = (() => {
      const key = "brewlio_sid";
      let id = localStorage.getItem(key);
      if (!id) {
        id = crypto.randomUUID?.() || (Date.now().toString(36) + Math.random().toString(36).slice(2));
        localStorage.setItem(key, id);
      }
      return id;
    })();

    const nowMs = () => Date.now();

    // Persist run + start time across accidental reloads (session-only)
    const runIdKey = "brewlio_runId";
    const startKey = "brewlio_quizStartMs";

    let runId = sessionStorage.getItem(runIdKey);
    if (!runId) {
      runId = crypto.randomUUID?.() || (Date.now().toString(36) + Math.random().toString(36).slice(2));
      sessionStorage.setItem(runIdKey, runId);
    }

    let quizStartMs = Number(sessionStorage.getItem(startKey));
    if (!quizStartMs || Number.isNaN(quizStartMs)) {
      quizStartMs = nowMs();
      sessionStorage.setItem(startKey, String(quizStartMs));
    }

    const form = document.getElementById('coffeeQuiz');
    const allQuestions = Array.from(document.querySelectorAll('.question'));
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const submitBtn = document.getElementById('submitBtn');
    const progress = document.querySelector('.progress');
    const results = document.getElementById('results');
    const recommendation = document.getElementById('recommendation');
    const stepText = document.getElementById('stepText');
    const stepHint = document.getElementById('stepHint');
    const errorText = document.getElementById('errorText');
    const retakeBtn = document.getElementById('retakeBtn');
    const grinderHint = document.getElementById('grinderHint');

    function getAnswer(name) {
      return form.querySelector(`input[name="${name}"]:checked`)?.value || null;
    }

    /**
     * Event-stream logger.
     * - ALWAYS sets derived.event_type (so SQL filters work)
     * - Allows overrides so COMPLETE can carry final match + full answers
     */
    async function logFunnelEvent(eventType, data = {}, overrides = {}) {
      if (!sb) return;

      try {
        const brew = getAnswer('brew') || null;
        const grinder = getAnswer('grinder') || null;
        const machine = brew === 'espresso' ? (getAnswer('machine') || null) : null;

        const duration = overrides.duration_ms ?? Math.max(0, nowMs() - quizStartMs);

        const payload = {
          submission_id: runId,
          session_id: sessionId,
          page: location.pathname,
          quiz_version: "v2.4-stage0",
          duration_ms: duration,

          brew,
          grinder,
          machine,

          milk: getAnswer('milk') || null,
          flavour: getAnswer('flavour') || null,
          roast_pref: getAnswer('roast') || null,
          skill: getAnswer('skill') || null,
          pain: getAnswer('pain') || null,

          // COMPLETE can override these. Other events keep them null.
          match_roast: overrides.match_roast ?? null,
          match_style: overrides.match_style ?? null,
          match_origins: overrides.match_origins ?? null,

          // Allow COMPLETE to store the full final answers object.
          // For "answer" events we store a single-key delta.
          answers: overrides.answers ?? (
            eventType === 'answer'
              ? { [data.question || 'unknown']: data.value ?? null }
              : null
          ),

          // ALWAYS include event_type
          derived: { event_type: eventType, ...data }
        };

        const { error } = await sb.from("quiz_events").insert(payload);
        if (error) console.warn("Supabase funnel error:", error);
      } catch (err) {
        console.warn("Funnel log failed:", err);
      }
    }

    function setGrinderHint(brew) {
      if (!grinderHint) return;
      grinderHint.textContent = (brew === 'espresso')
        ? "Hand grinders count — great for filter; espresso is a workout."
        : "Hand grinders count — coarser brews are their happy place.";
    }

    function labelForGrinder(v) {
      const map = {
        "pre-ground": "Pre-ground",
        "blade": "Blade grinder",
        "burr-entry": "Entry burr",
        "burr-good": "Good burr",
        "pro": "High-end / commercial"
      };
      return map[v] || (v ? v.replace(/-/g, ' ') : "—");
    }

    function labelForBrew(v) {
      const map = {
        "espresso": "Espresso",
        "manual": "Manual filter",
        "batch": "Batch filter",
        "body": "Immersion / stovetop",
        "other": "Other / instant"
      };
      return map[v] || (v ? v : "—");
    }

    function labelForMilk(v) {
      const map = {
        "black": "Black",
        "sometimes": "Sometimes milk",
        "always": "Milk"
      };
      return map[v] || "—";
    }

    function labelForFlavour(v) {
      const map = {
        "fruity": "Juicy fruit",
        "clean": "Clean & tea-like",
        "chocolate": "Chocolatey & nutty",
        "balanced": "Balanced",
        "bold": "Rich & heavy"
      };
      return map[v] || "—";
    }

    function labelForPain(v) {
      const map = {
        "sour": "Sour / sharp",
        "bitter": "Bitter / harsh",
        "weak": "Weak / watery",
        "muddy": "Muddy / gritty",
        "inconsistent": "Inconsistent"
      };
      return map[v] || "—";
    }

    let currentIndex = 0;
    let activeQuestions = [];
    let isSubmitting = false;

    results.hidden = true;
    form.hidden = false;

    function rebuildActiveQuestions() {
      const brew = getAnswer('brew');
      activeQuestions = allQuestions.filter(q => {
        const cond = q.getAttribute('data-conditional');
        return !cond || cond === brew;
      });

      const machine = allQuestions.find(q => q.getAttribute('data-q') === 'machine');
      if (machine) {
        const inputs = machine.querySelectorAll('input[type="radio"]');
        const isActive = activeQuestions.includes(machine);
        inputs.forEach(i => i.required = isActive);
        if (!isActive) inputs.forEach(i => i.checked = false);
      }

      currentIndex = Math.min(currentIndex, activeQuestions.length - 1);
    }

    function total() { return activeQuestions.length; }
    function isAnswered(idx) { return !!activeQuestions[idx]?.querySelector('input[type="radio"]:checked'); }

    function setButtons() {
      prevBtn.disabled = currentIndex === 0;

      const last = currentIndex === total() - 1;
      const answered = isAnswered(currentIndex);

      nextBtn.classList.toggle('hidden', last);
      submitBtn.classList.toggle('hidden', !last);

      nextBtn.disabled = !answered;
      submitBtn.disabled = !answered;

      stepText.textContent = `Question ${currentIndex + 1} of ${total()}`;
      stepHint.textContent = answered ? 'Nice — continue' : 'Pick one to continue';
    }

    // ✅ PATCH (mobile video reliability):
    // pause all question videos, then try to play only the active one.
    function pauseAllQuestionVideos() {
      document.querySelectorAll('video.q-video').forEach(v => {
        try { v.pause(); } catch (e) {}
      });
    }

    function playActiveQuestionVideo(activeEl) {
      const v = activeEl?.querySelector('video.q-video');
      if (!v) return;
      try {
        const p = v.play();
        if (p && typeof p.catch === 'function') p.catch(() => {});
      } catch (e) {}
    }

    function showQuestion(idx) {
      allQuestions.forEach(q => q.classList.remove('active'));
      activeQuestions[idx].classList.add('active');

      // ✅ PATCH: play only the active video (helps iOS/Safari)
      pauseAllQuestionVideos();
      playActiveQuestionVideo(activeQuestions[idx]);

      errorText.textContent = '';
      progress.style.width = `${((idx + 1) / total()) * 100}%`;
      setButtons();

      logFunnelEvent('view_question', { question_index: idx, total_questions: total() });

      activeQuestions[idx].scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    form.addEventListener('change', (e) => {
      if (!e.target.matches('input[type="radio"]')) return;

      // Log once per answer
      logFunnelEvent('answer', {
        question: e.target.name,
        value: e.target.value,
        question_index: currentIndex,
        total_questions: total()
      });

      if (e.target.name === 'brew') {
        const brew = getAnswer('brew') || 'other';
        setGrinderHint(brew);
        rebuildActiveQuestions();
        showQuestion(currentIndex);
        return;
      }

      setButtons();
    });

    nextBtn.addEventListener('click', () => {
      if (!isAnswered(currentIndex)) { errorText.textContent = 'Pick an option to continue.'; return; }
      logFunnelEvent('nav_next', { from_index: currentIndex, to_index: currentIndex + 1, total_questions: total() });
      currentIndex++;
      showQuestion(currentIndex);
    });

    prevBtn.addEventListener('click', () => {
      logFunnelEvent('nav_prev', { from_index: currentIndex, to_index: currentIndex - 1, total_questions: total() });
      currentIndex--;
      showQuestion(currentIndex);
    });

    // Recommendation helpers
    function pickOrigins({ roast, flavour, brew, milk }) {
      const pools = {
        light: ["Ethiopia", "Kenya", "Costa Rica", "Rwanda", "Tanzania"],
        mediumSweet: ["Brazil", "Colombia", "Guatemala", "El Salvador", "Costa Rica"],
        mediumClean: ["Colombia", "Costa Rica", "Kenya", "Rwanda", "Guatemala"],
        mediumDark: ["Brazil", "Colombia", "Guatemala", "Honduras", "Indonesia (Sumatra)"],
        dark: ["Brazil", "Indonesia (Sumatra)", "India", "Vietnam"]
      };

      let selectedPool = pools.mediumSweet;

      if (roast === 'light') selectedPool = pools.light;
      else if (roast === 'medium-dark') selectedPool = pools.mediumDark;
      else if (roast === 'dark') selectedPool = pools.dark;
      else if (roast === 'medium') {
        if (flavour === 'chocolate' || flavour === 'bold') selectedPool = pools.mediumSweet;
        else selectedPool = pools.mediumClean;
      }

      if (brew === 'espresso' && milk === 'always' && roast !== 'dark') {
        selectedPool = pools.mediumSweet;
      }

      const shuffled = [...selectedPool].sort(() => 0.5 - Math.random());
      const origin1 = shuffled[0];
      const origin2 = shuffled[1] || shuffled[0];

      return `${origin1} or ${origin2}`;
    }

    function pushUnique(arr, msg) { if (!arr.includes(msg)) arr.push(msg); }

    function resultStyleLine(roast, flavour, brew, milk) {
      const isMilk = (milk === 'always');
      const isFilter = (brew === 'manual' || brew === 'batch');

      if (roast === 'light') {
        if (flavour === 'chocolate' || flavour === 'bold') return "a lighter cup that’s still sweet (not sour-for-fun)";
        if (isMilk) return "something light-leaning, but with enough sweetness to survive milk";
        return "a bright, clean cup with high clarity";
      }

      if (roast === 'medium') {
        if (flavour === 'fruity') return "sweet cups with a little sparkle (no sharp edges)";
        if (flavour === 'clean') return "clean sweetness and clarity (without going full lemon-water)";
        if (flavour === 'bold') return "comfort flavours with some weight — sweet, not ashy";
        if (isMilk) return "sweet, milk-friendly comfort flavours";
        return "sweet, balanced, easy-to-love cups";
      }

      if (roast === 'medium-dark') {
        if (isFilter) return "syrupy sweetness without the harsh roast bite";
        if (isMilk) return "thicker, milk-friendly sweetness (choc/caramel energy)";
        return "richer body with a sweet finish";
      }

      if (flavour === 'fruity' || flavour === 'clean') return "roasty comfort (not a fruit salad)";
      return "big, roasty comfort flavours with low acidity";
    }

    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      if (isSubmitting) return;
      if (!isAnswered(currentIndex)) { errorText.textContent = 'Pick an option to see your result.'; return; }

      isSubmitting = true;
      submitBtn.disabled = true;
      const originalSubmitText = submitBtn.textContent;
      submitBtn.textContent = "Saving…";

      const submissionId = runId;

      try {
        const a = Object.fromEntries(new FormData(form));

        const brew = a.brew || 'other';
        const grinder = a.grinder || 'pre-ground';
        const machine = a.machine || 'not-sure';
        const skill = a.skill || 'basic';
        const pain = a.pain || 'inconsistent';
        const roastPrefAny = (a.roast === 'any');

        const requestedRoast = (!roastPrefAny && a.roast) ? a.roast : null;
        let roast = requestedRoast || 'medium';

        const strongNotes = [];

        let styleLabel = 'balanced & sweet';
        if (a.flavour === 'fruity') styleLabel = 'juicy fruit';
        if (a.flavour === 'clean') styleLabel = 'clean, tea-like';
        if (a.flavour === 'chocolate') styleLabel = 'choc / nut / caramel';
        if (a.flavour === 'balanced') styleLabel = 'balanced & sweet';
        if (a.flavour === 'bold') styleLabel = 'rich & heavy';

        const hasWeakGrinder = ['pre-ground', 'blade', 'burr-entry'].includes(grinder);
        const hasGoodGrinder = (grinder === 'burr-good' || grinder === 'pro');
        const hasAdvancedSkill = (skill === 'advanced' || skill === 'nerd');

        function overrideRoast(newRoast, note) {
          if (roast !== newRoast) {
            roast = newRoast;
            pushUnique(strongNotes, note);
          }
        }

        // === REFINED LOGIC: Respect preference + expertise ===
        if (requestedRoast) {
          if (hasWeakGrinder && roast === 'light') {
            overrideRoast('medium-dark', "Light roasts need consistent grind. With entry-level grinding, they often taste sour. Medium-dark is more reliable.");
          }

          if (a.milk === 'always' && roast === 'light' && !(hasGoodGrinder && hasAdvancedSkill)) {
            overrideRoast('medium-dark', "Milk can mask the delicate notes in light roasts. Medium-dark usually gives better body and sweetness with milk.");
          }

          if ((brew === 'manual' || brew === 'batch') && roast === 'dark') {
            overrideRoast('medium', "Dark roasts in filter can taste harsh or ashy. Medium keeps sweetness and clarity.");
          }

          if (brew === 'espresso' && roast === 'light') {
            if (!hasGoodGrinder) {
              overrideRoast('medium', "Light roast espresso needs a capable burr grinder to avoid sour, uneven shots. Medium is more forgiving.");
            }
            const entryMachine = (machine === 'entry' || machine === 'not-sure');
            if (entryMachine && !hasAdvancedSkill) {
              overrideRoast('medium', "Light roasts on entry machines can be uneven. Medium extracts more consistently.");
            }
          }

          if (!hasAdvancedSkill) {
            if (pain === 'sour' && roast === 'light') {
              overrideRoast('medium', "If sourness bothers you, light roasts can amplify it. Medium is easier to extract sweetly.");
            }
            if (pain === 'bitter' && roast === 'dark') {
              overrideRoast('medium-dark', "If bitter is the enemy, very dark roasts can make it worse. Medium-dark is often cleaner.");
            }
          }

          if (pain === 'muddy' && hasWeakGrinder) {
            if (roast === 'light') overrideRoast('medium', "Muddy texture often comes from inconsistent grind. Medium roasts are more forgiving.");
            if (roast === 'dark') overrideRoast('medium-dark', "Very dark with fines can feel muddy. Medium-dark is usually cleaner.");
          }
        }

        // Gentle nudges (only if no strong preference)
        if (!requestedRoast || requestedRoast === 'medium') {
          if (a.milk === 'always' && (a.flavour === 'bold' || a.flavour === 'chocolate') && (brew === 'espresso' || brew === 'body') && !hasAdvancedSkill) {
            roast = 'medium-dark';
          }
        }

        // "Any roast" → intelligent default
        if (roastPrefAny) {
          roast = 'medium';
          if (hasGoodGrinder && hasAdvancedSkill && (a.flavour === 'fruity' || a.flavour === 'clean')) {
            roast = 'light';
          } else if ((brew === 'espresso' || brew === 'body') && a.milk === 'always') {
            roast = 'medium-dark';
          }
        }

        const recs = {
          light: { title: 'Light Roast', why: 'More origin character, less roast taste. Bright when extracted well.' },
          medium: { title: 'Medium Roast', why: 'Sweet, forgiving, and works on most setups without drama.' },
          'medium-dark': { title: 'Medium-Dark Roast', why: 'Syrupy body, great with milk, and generally hard to mess up.' },
          dark: { title: 'Dark Roast', why: 'Big roast taste, low acidity, very forgiving (if that’s your vibe).' }
        };

        const pick = recs[roast] || recs.medium;

        const origins = pickOrigins({ roast, flavour: a.flavour, brew, milk: a.milk });
        const displayStyle = resultStyleLine(roast, a.flavour, brew, a.milk);

        const brewText = ({
          espresso: 'espresso',
          manual: 'manual filter',
          batch: 'batch filter',
          body: 'immersion / stovetop',
          other: 'other'
        }[brew] || brew);

        const milkText = (a.milk === 'black') ? 'black' : (a.milk === 'always' ? 'with milk' : 'either');

        const durationMs = Math.max(0, nowMs() - quizStartMs);

        // Profile summary (trust + identity)
        const profileHTML = `
          <div class="why-box why-box--profile">
            <p class="why-title">Your profile</p>
            <p class="why-meta"><strong>Brew:</strong> ${labelForBrew(brew)}</p>
            <p class="why-meta"><strong>Milk:</strong> ${labelForMilk(a.milk)}</p>
            <p class="why-meta"><strong>Grinder:</strong> ${labelForGrinder(grinder)}</p>
            <p class="why-meta"><strong>Taste:</strong> ${labelForFlavour(a.flavour)}</p>
            <p class="why-meta"><strong>Deal-breaker:</strong> ${labelForPain(pain)}</p>
          </div>
        `;

        let html = `
          <div class="result-card">
            <p class="rec-title">Your coffee style:</p>
            <h3>${pick.title}</h3>
            <p class="result-line">You’ll likely enjoy <strong>${displayStyle}</strong> — think <strong>${origins}</strong>.</p>

            ${profileHTML}

            <div class="why-box">
              <p class="why-title">Why this fits you</p>
              <p>${pick.why}</p>
              <p class="why-meta">
                Built for <strong>${brewText}</strong>, drinking it <strong>${milkText}</strong>,
                with a <strong>${grinder.replace(/-/g, ' ')}</strong> grinder.
              </p>
              <p class="why-meta">This prioritises consistency over perfection — on purpose.</p>
            </div>
        `;

        if (strongNotes.length > 0) {
          html += `
            <div class="why-box why-box--note">
              <p class="why-title">A note from experience</p>
              <ul class="note-list">
                ${strongNotes.map(n => `<li>${n}</li>`).join('')}
              </ul>
            </div>
          `;
        }

        html += `
         <div class="why-box cta-panel cta-panel--results">
  <p class="why-title cta-title">Get matched coffees — only when they actually fit</p>
  <p class="cta-copy">
    We’ll email you 1–3 coffees from real roasters that genuinely match this exact profile
    — your setup, taste, and deal-breakers included.
  </p>

  <ul class="note-list" style="margin: 16px 0 20px;">
    <li>No random recommendations — only coffees that work for <em>your</em> grinder and brew</li>
    <li>Save time and money — skip the regret bags</li>
    <li>Your full profile summary (so you can shop smarter anywhere)</li>
  </ul>

  <form id="emailForm" class="email-form">
    <input
      type="email"
      id="userEmail"
      placeholder="your@email.com"
      required
      aria-label="Your email address"
      class="email-input"
    />

    <select id="buySource" class="email-input" aria-label="Where do you usually buy coffee?">
      <option value="" selected>Where do you usually buy coffee? (optional)</option>
      <option value="supermarket">Supermarket</option>
      <option value="cafe">Cafe / barista</option>
      <option value="local_roaster">Local roaster</option>
      <option value="online">Online</option>
      <option value="subscription">Subscription</option>
    </select>

    <button type="submit" class="quiz-btn primary email-submit">
      Send me matches
    </button>
  </form>

  <p class="email-footnote">
    No spam. No daily emails. Unsubscribe anytime with one click.
  </p>
</div>
        `;

        html += `<p class="results-next small">Pilot mode: you’re getting style guidance today. Partner picks will be added to this profile as we onboard roasters.</p></div>`;

        recommendation.innerHTML = html;

        results.hidden = false;
        form.hidden = true;
        results.scrollIntoView({ behavior: 'smooth', block: 'start' });

        // ✅ SINGLE source of truth:
        // Store the final result as the COMPLETE event row (with match_* and full answers)
        await logFunnelEvent(
          'complete',
          {
            // keep rich context in derived too (useful for debugging)
            roast,
            styleLabel,
            origins,
            brew,
            grinder,
            machine: brew === 'espresso' ? machine : null,
            skill,
            pain,
            buy_source: null,
            notes: { strong: strongNotes }
          },
          {
            duration_ms: durationMs,
            match_roast: roast || null,
            match_style: styleLabel || null,
            match_origins: origins || null,
            answers: a
          }
        );

        // Email form handler
        const emailForm = document.getElementById('emailForm');
        if (emailForm && sb) {
          emailForm.addEventListener('submit', async (ev) => {
            ev.preventDefault();
            const emailInput = document.getElementById('userEmail');
            const buySource = document.getElementById('buySource')?.value || null;
            const email = emailInput?.value.trim();
            emailInput?.classList.remove('input-error');

            logFunnelEvent('email_submit', { buy_source: buySource });

            if (!email || !email.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)) {
              emailInput.classList.add('input-error');
              logFunnelEvent('email_fail', { reason: 'invalid_email', buy_source: buySource });
              return;
            }

            const btn = emailForm.querySelector('button[type="submit"]');
            const origText = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Saving…';

            try {
              const { error } = await sb.from('email_signups').insert({
                email: email,
                session_id: sessionId,
                submission_id: submissionId,
                source: 'quiz_result'
              });
              if (error) throw error;

              logFunnelEvent('email_success', { buy_source: buySource });
              emailForm.innerHTML = `<p class="email-success">You’re in — we’ll email when something genuinely fits this profile.</p>`;
              return;
            } catch (err) {
              console.warn('Email signup failed:', err);
              logFunnelEvent('email_fail', { reason: 'insert_failed', buy_source: buySource });
              btn.textContent = 'Try again';
            } finally {
              if (!btn || !btn.isConnected) return;
              btn.disabled = false;
              if (origText) btn.textContent = origText;
            }
          });
        }

      } catch (err) {
        console.warn("Submit failed:", err);
      } finally {
        submitBtn.textContent = originalSubmitText;
      }
    });

    retakeBtn.addEventListener('click', () => {
      isSubmitting = false;

      // new run id + reset timer (and persist)
      runId = crypto.randomUUID?.() || (Date.now().toString(36) + Math.random().toString(36).slice(2));
      sessionStorage.setItem(runIdKey, runId);

      quizStartMs = nowMs();
      sessionStorage.setItem(startKey, String(quizStartMs));

      form.reset();
      results.hidden = true;
      form.hidden = false;

      currentIndex = 0;
      rebuildActiveQuestions();
      setGrinderHint(getAnswer('brew') || 'other');
      showQuestion(currentIndex);

      logFunnelEvent('start', { question_index: 0, total_questions: total(), retake: true });
    });

    rebuildActiveQuestions();
    setGrinderHint(getAnswer('brew') || 'other');
    showQuestion(0);
    logFunnelEvent('start', { question_index: 0, total_questions: total() });
  </script>
</body>
</html>
